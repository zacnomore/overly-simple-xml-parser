{"version":3,"file":"index.js","sources":["../../src/models.ts","../../src/parser.ts"],"sourcesContent":["export class XmlNode {\n    public child: { [key: string]: XmlNode[]} = {};\n    public attrsMap?: AttributeMap;\n  \n    constructor(public tagname: string, public parent: XmlNode | undefined, public val: AllowedTypes) {}\n  \n    addChild(child: XmlNode) {\n      if (Array.isArray(this.child[child.tagname])) {\n        //already presents\n        this.child[child.tagname].push(child);\n      } else {\n        this.child[child.tagname] = [child];\n      }\n    }\n  }\n  export type AllowedTypes = string | number | boolean | undefined;\n  export type AttributeMap = { [key: string]: AllowedTypes };\n  export type ParsedObject = { [key: string]: Object | unknown[]};","import { XmlNode, ParsedObject, AllowedTypes, AttributeMap } from \"./models\";\n\nexport function parse(xmlData: string) {\n  const traversableObj = getTraversalObj(xmlData);\n  return convertToJson(traversableObj);\n}\n\nexport function convertToJson(node: XmlNode): ParsedObject | AllowedTypes {\n  const jObj: ParsedObject = {};\n\n  const isEmptyObject = (obj: object) => Object.keys(obj).length === 0;\n  //when no child node or attr is present\n  if ((isEmptyObject(node.child)) && (!node.attrsMap || isEmptyObject(node.attrsMap))) {\n    return isExist(node.val) ? node.val : '';\n  } else if (isExist(node.val) && (!(typeof node.val === 'string' && (node.val === '' || node.val === '\\\\c')))) {\n    jObj['#text'] = node.val;\n  }\n\n  Object.assign(jObj, node.attrsMap);\n\n  Object.entries(node.child).forEach(([key, value]) => {\n    if (Array.isArray(value) && value.length > 1) {\n      jObj[key] = [];\n      for (var tag in value) {\n        (jObj[key] as unknown[]).push(convertToJson(value[tag]));\n      }\n    } else {\n      const jsVal = convertToJson(value[0]);\n      if(jsVal) {\n        jObj[key] = jsVal; \n      }\n    }\n  });\n\n  //add value\n  return jObj;\n}\n\n function isExist(v: Object | undefined): v is Object {\n  return typeof v !== 'undefined';\n}\n\nexport function getTraversalObj(xmlData: string): XmlNode {\n  xmlData = xmlData.replace(/(\\r\\n)|\\n/, \" \");\n  const xmlObj = new XmlNode('!xml', undefined, undefined);\n  let currentNode: XmlNode = xmlObj;\n  let textData: string = \"\";\n\n  for(let i = 0; i < xmlData.length; i++) {\n    const ch = xmlData[i];\n    if(ch === '<') {\n      if( xmlData[i+1] === '/') { //Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        if(currentNode) {\n          if(currentNode.val) {\n            currentNode.val = getValue(currentNode.val) + '' + processTagValue(textData);\n          } else{\n            currentNode.val = processTagValue(textData);\n          }\n        }\n        // @ts-expect-error\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\")\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"-->\", i, \"Comment is not closed.\")\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\")\n        const tagExp = xmlData.substring(i, closeIndex);\n        if(tagExp.indexOf(\"[\") >= 0) {\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        } else{\n          i = closeIndex;\n        }\n      } else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if(textData) {\n          currentNode.val = getValue(currentNode.val) + '' + processTagValue(textData);\n          textData = \"\";\n        }\n        currentNode.val = (currentNode.val || '') + (tagExp || '');\n\n        i = closeIndex + 2;\n      } else {//Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i+1)\n        let tagExp = result.data || '';\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        if(separatorIndex !== -1) {\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml') {\n            currentNode.val = getValue(currentNode.val) + '' + processTagValue(textData);\n          }\n        }\n\n        if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1) { //selfClosing tag\n\n          if(tagName[tagName.length - 1] === \"/\") { //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          } else{\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new XmlNode(tagName, currentNode, '');\n          if(tagName !== tagExp) {\n            childNode.attrsMap = buildAttributesMap(tagExp);\n          }\n          currentNode.addChild(childNode);\n        } else{//opening tag\n\n          const childNode = new XmlNode( tagName, currentNode, undefined);\n          if(tagName !== tagExp) {\n            childNode.attrsMap = buildAttributesMap(tagExp);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    } else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n}\n\nfunction findClosingIndex(xmlData: string, str: string, i: number, errMsg: string): number {\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1) {\n    throw new Error(errMsg)\n  } else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction getValue(v: AllowedTypes): Omit<AllowedTypes, 'undefined'> {\n  if (isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n}\n\nfunction processTagValue(val: string): string | number | boolean {\n  if(val === 'false' || val === 'true') {\n    return val === 'true';\n  } else if (val.indexOf('0x') !== -1) {\n    //support hexa decimal\n    return parseInt(val, 16);\n  } else if (val.indexOf('.') !== -1 && !isNaN(parseFloat(val))) {\n    return parseFloat(val);\n  } else if (!isNaN(parseInt(val))) {\n    return parseInt(val, 10);\n  } else {\n    return val.trim();\n  }\n}\n\n\nfunction closingIndexForOpeningTag(data: string, i: number): { data: string, index: number} {\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\"; //reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === '>') {\n        return {\n          index,\n          data: tagExp\n        }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n\n  throw new Error('Tag not closed');\n}\n\n\nfunction buildAttributesMap(attrStr: string): AttributeMap | undefined {\n  attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n\n  const attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n  const matches = getAllMatches(attrStr, attrsRegx);\n  const len = matches.length;\n  if (len === 0) { return; }\n  const attrs: AttributeMap = {};\n  for (let i = 0; i < len; i++) {\n    const attrName = matches[i][1];\n    if (attrName.length) {\n      const namePrefix = '@_';\n      if (matches[i][4] !== undefined) {\n        matches[i][4] = matches[i][4].trim();\n        attrs[namePrefix + attrName] = matches[i][4];\n      }\n    }\n  }\n  return attrs;\n}\n\n\nfunction getAllMatches(string: string, regex: RegExp): string[][] {\n  const matches: string[][] = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches: string[] = [];\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n}\n"],"names":[],"mappings":";;;;AAAA;IAII,iBAAmB,OAAe,EAAS,MAA2B,EAAS,GAAiB;QAA7E,YAAO,GAAP,OAAO,CAAQ;QAAS,WAAM,GAAN,MAAM,CAAqB;QAAS,QAAG,GAAH,GAAG,CAAc;QAHzF,UAAK,GAAgC,EAAE,CAAC;KAGqD;IAEpG,0BAAQ,GAAR,UAAS,KAAc;QACrB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,EAAE;YAE5C,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SACvC;aAAM;YACL,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;SACrC;KACF;IACH,cAAC;AAAD,CAAC;;SCZa,KAAK,CAAC,OAAe;IACnC,IAAM,cAAc,GAAG,eAAe,CAAC,OAAO,CAAC,CAAC;IAChD,OAAO,aAAa,CAAC,cAAc,CAAC,CAAC;AACvC,CAAC;SAEe,aAAa,CAAC,IAAa;IACzC,IAAM,IAAI,GAAiB,EAAE,CAAC;IAE9B,IAAM,aAAa,GAAG,UAAC,GAAW,IAAK,OAAA,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,GAAA,CAAC;IAErE,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,IAAI,aAAa,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,EAAE;QACnF,OAAO,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,GAAG,EAAE,CAAC;KAC1C;SAAM,IAAI,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,OAAO,IAAI,CAAC,GAAG,KAAK,QAAQ,KAAK,IAAI,CAAC,GAAG,KAAK,EAAE,IAAI,IAAI,CAAC,GAAG,KAAK,KAAK,CAAC,CAAC,CAAC,EAAE;QAC5G,IAAI,CAAC,OAAO,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC;KAC1B;IAED,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;IAEnC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,OAAO,CAAC,UAAC,EAAY;YAAX,GAAG,QAAA,EAAE,KAAK,QAAA;QAC7C,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YAC5C,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;YACf,KAAK,IAAI,GAAG,IAAI,KAAK,EAAE;gBACpB,IAAI,CAAC,GAAG,CAAe,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;aAC1D;SACF;aAAM;YACL,IAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;YACtC,IAAG,KAAK,EAAE;gBACR,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;aACnB;SACF;KACF,CAAC,CAAC;IAGH,OAAO,IAAI,CAAC;AACd,CAAC;AAEA,SAAS,OAAO,CAAC,CAAqB;IACrC,OAAO,OAAO,CAAC,KAAK,WAAW,CAAC;AAClC,CAAC;SAEe,eAAe,CAAC,OAAe;IAC7C,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC;IAC5C,IAAM,MAAM,GAAG,IAAI,OAAO,CAAC,MAAM,EAAE,SAAS,EAAE,SAAS,CAAC,CAAC;IACzD,IAAI,WAAW,GAAY,MAAM,CAAC;IAClC,IAAI,QAAQ,GAAW,EAAE,CAAC;IAE1B,KAAI,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,IAAM,EAAE,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;QACtB,IAAG,EAAE,KAAK,GAAG,EAAE;YACb,IAAI,OAAO,CAAC,CAAC,GAAC,CAAC,CAAC,KAAK,GAAG,EAAE;gBACxB,IAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE,4BAA4B,CAAC,CAAA;gBAClF,IAAG,WAAW,EAAE;oBACd,IAAG,WAAW,CAAC,GAAG,EAAE;wBAClB,WAAW,CAAC,GAAG,GAAG,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;qBAC9E;yBAAK;wBACJ,WAAW,CAAC,GAAG,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;qBAC7C;iBACF;gBAED,WAAW,GAAG,WAAW,CAAC,MAAM,CAAC;gBACjC,QAAQ,GAAG,EAAE,CAAC;gBACd,CAAC,GAAG,UAAU,CAAC;aAChB;iBAAM,IAAI,OAAO,CAAC,CAAC,GAAC,CAAC,CAAC,KAAK,GAAG,EAAE;gBAC/B,CAAC,GAAG,gBAAgB,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC,EAAE,uBAAuB,CAAC,CAAA;aAChE;iBAAM,IAAG,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE;gBAC5C,CAAC,GAAG,gBAAgB,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,wBAAwB,CAAC,CAAA;aAClE;iBAAM,IAAI,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;gBAC5C,IAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE,CAAC,EAAE,wBAAwB,CAAC,CAAA;gBAC9E,IAAM,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,EAAE,UAAU,CAAC,CAAC;gBAChD,IAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;oBAC3B,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;iBAClC;qBAAK;oBACJ,CAAC,GAAG,UAAU,CAAC;iBAChB;aACF;iBAAM,IAAG,OAAO,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,KAAK,IAAI,EAAE;gBAC3C,IAAM,UAAU,GAAG,gBAAgB,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,EAAE,sBAAsB,CAAC,GAAG,CAAC,CAAA;gBAClF,IAAM,MAAM,GAAG,OAAO,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,EAAC,UAAU,CAAC,CAAC;gBAKnD,IAAG,QAAQ,EAAE;oBACX,WAAW,CAAC,GAAG,GAAG,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;oBAC7E,QAAQ,GAAG,EAAE,CAAC;iBACf;gBACD,WAAW,CAAC,GAAG,GAAG,CAAC,WAAW,CAAC,GAAG,IAAI,EAAE,KAAK,MAAM,IAAI,EAAE,CAAC,CAAC;gBAE3D,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC;aACpB;iBAAM;gBACL,IAAM,MAAM,GAAG,yBAAyB,CAAC,OAAO,EAAE,CAAC,GAAC,CAAC,CAAC,CAAA;gBACtD,IAAI,MAAM,GAAG,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC;gBAC/B,IAAM,UAAU,GAAG,MAAM,CAAC,KAAK,CAAC;gBAChC,IAAM,cAAc,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;gBAC3C,IAAI,OAAO,GAAG,MAAM,CAAC;gBACrB,IAAG,cAAc,KAAK,CAAC,CAAC,EAAE;oBACxB,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;oBACjE,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,cAAc,GAAG,CAAC,CAAC,CAAC;iBAC5C;gBAGD,IAAI,WAAW,IAAI,QAAQ,EAAE;oBAC3B,IAAG,WAAW,CAAC,OAAO,KAAK,MAAM,EAAE;wBACjC,WAAW,CAAC,GAAG,GAAG,QAAQ,CAAC,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,eAAe,CAAC,QAAQ,CAAC,CAAC;qBAC9E;iBACF;gBAED,IAAG,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;oBAErE,IAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;wBACtC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC,EAAE,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;wBAChD,MAAM,GAAG,OAAO,CAAC;qBAClB;yBAAK;wBACJ,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;qBAC9C;oBAED,IAAM,SAAS,GAAG,IAAI,OAAO,CAAC,OAAO,EAAE,WAAW,EAAE,EAAE,CAAC,CAAC;oBACxD,IAAG,OAAO,KAAK,MAAM,EAAE;wBACrB,SAAS,CAAC,QAAQ,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC;qBACjD;oBACD,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;iBACjC;qBAAK;oBAEJ,IAAM,SAAS,GAAG,IAAI,OAAO,CAAE,OAAO,EAAE,WAAW,EAAE,SAAS,CAAC,CAAC;oBAChE,IAAG,OAAO,KAAK,MAAM,EAAE;wBACrB,SAAS,CAAC,QAAQ,GAAG,kBAAkB,CAAC,MAAM,CAAC,CAAC;qBACjD;oBACD,WAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;oBAChC,WAAW,GAAG,SAAS,CAAC;iBACzB;gBACD,QAAQ,GAAG,EAAE,CAAC;gBACd,CAAC,GAAG,UAAU,CAAC;aAChB;SACF;aAAK;YACJ,QAAQ,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC;SACxB;KACF;IACD,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,gBAAgB,CAAC,OAAe,EAAE,GAAW,EAAE,CAAS,EAAE,MAAc;IAC/E,IAAM,YAAY,GAAG,OAAO,CAAC,OAAO,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;IAC7C,IAAG,YAAY,KAAK,CAAC,CAAC,EAAE;QACtB,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,CAAA;KACxB;SAAK;QACJ,OAAO,YAAY,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;KACtC;AACH,CAAC;AAED,SAAS,QAAQ,CAAC,CAAe;IAC/B,IAAI,OAAO,CAAC,CAAC,CAAC,EAAE;QACd,OAAO,CAAC,CAAC;KACV;SAAM;QACL,OAAO,EAAE,CAAC;KACX;AACH,CAAC;AAED,SAAS,eAAe,CAAC,GAAW;IAClC,IAAG,GAAG,KAAK,OAAO,IAAI,GAAG,KAAK,MAAM,EAAE;QACpC,OAAO,GAAG,KAAK,MAAM,CAAC;KACvB;SAAM,IAAI,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;QAEnC,OAAO,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;KAC1B;SAAM,IAAI,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE;QAC7D,OAAO,UAAU,CAAC,GAAG,CAAC,CAAC;KACxB;SAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,EAAE;QAChC,OAAO,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;KAC1B;SAAM;QACL,OAAO,GAAG,CAAC,IAAI,EAAE,CAAC;KACnB;AACH,CAAC;AAGD,SAAS,yBAAyB,CAAC,IAAY,EAAE,CAAS;IACxD,IAAI,YAAY,CAAC;IACjB,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE;QAChD,IAAI,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC;QACrB,IAAI,YAAY,EAAE;YACd,IAAI,EAAE,KAAK,YAAY;gBAAE,YAAY,GAAG,EAAE,CAAC;SAC9C;aAAM,IAAI,EAAE,KAAK,GAAG,IAAI,EAAE,KAAK,GAAG,EAAE;YACjC,YAAY,GAAG,EAAE,CAAC;SACrB;aAAM,IAAI,EAAE,KAAK,GAAG,EAAE;YACnB,OAAO;gBACL,KAAK,OAAA;gBACL,IAAI,EAAE,MAAM;aACb,CAAA;SACJ;aAAM,IAAI,EAAE,KAAK,IAAI,EAAE;YACtB,EAAE,GAAG,GAAG,CAAA;SACT;QACD,MAAM,IAAI,EAAE,CAAC;KACd;IAED,MAAM,IAAI,KAAK,CAAC,gBAAgB,CAAC,CAAC;AACpC,CAAC;AAGD,SAAS,kBAAkB,CAAC,OAAe;IACzC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;IAEzC,IAAM,SAAS,GAAG,IAAI,MAAM,CAAC,uCAAuC,EAAE,GAAG,CAAC,CAAC;IAC3E,IAAM,OAAO,GAAG,aAAa,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;IAClD,IAAM,GAAG,GAAG,OAAO,CAAC,MAAM,CAAC;IAC3B,IAAI,GAAG,KAAK,CAAC,EAAE;QAAE,OAAO;KAAE;IAC1B,IAAM,KAAK,GAAiB,EAAE,CAAC;IAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,CAAC,EAAE,EAAE;QAC5B,IAAM,QAAQ,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC/B,IAAI,QAAQ,CAAC,MAAM,EAAE;YACnB,IAAM,UAAU,GAAG,IAAI,CAAC;YACxB,IAAI,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,SAAS,EAAE;gBAC/B,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;gBACrC,KAAK,CAAC,UAAU,GAAG,QAAQ,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aAC9C;SACF;KACF;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAGD,SAAS,aAAa,CAAC,MAAc,EAAE,KAAa;IAClD,IAAM,OAAO,GAAe,EAAE,CAAC;IAC/B,IAAI,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;IAC/B,OAAO,KAAK,EAAE;QACZ,IAAM,UAAU,GAAa,EAAE,CAAC;QAChC,IAAM,GAAG,GAAG,KAAK,CAAC,MAAM,CAAC;QACzB,KAAK,IAAI,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,GAAG,EAAE,KAAK,EAAE,EAAE;YACxC,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC;SAC/B;QACD,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QACzB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;KAC5B;IACD,OAAO,OAAO,CAAC;AACjB;;;;;;"}